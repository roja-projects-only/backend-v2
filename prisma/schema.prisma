generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String               @id @default(cuid())
  username           String               @unique
  password           String
  role               UserRole             @default(STAFF)
  active             Boolean              @default(true)
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  auditLogs          AuditLog[]
  customers          Customer[]
  debtTransactions   DebtTransaction[]
  Payment            Payment[]
  PaymentTransaction PaymentTransaction[]
  sales              Sale[]
  sessions           Session[]
  settingsUpdates    Setting[]

  @@index([username])
}

model Customer {
  id              String    @id @default(cuid())
  name            String
  location        Location
  phone           String?
  customUnitPrice Float?
  notes           String?
  active          Boolean   @default(true)
  createdById     String
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  createdBy       User      @relation(fields: [createdById], references: [id])
  debtTabs        DebtTab[]
  Payment         Payment[]
  sales           Sale[]

  @@index([name])
  @@index([location])
  @@index([createdById])
}

model Sale {
  id          String      @id @default(cuid())
  quantity    Float
  unitPrice   Float
  total       Float
  date        DateTime
  notes       String?
  customerId  String
  userId      String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  paymentType PaymentType @default(CASH)
  Payment     Payment?
  customer    Customer    @relation(fields: [customerId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [id])

  @@unique([customerId, date], name: "unique_customer_date")
  @@index([customerId])
  @@index([userId])
  @@index([date])
  @@index([paymentType])
}

model Setting {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String
  type        String   @default("string")
  updatedById String
  updatedAt   DateTime @updatedAt
  updatedBy   User     @relation(fields: [updatedById], references: [id])

  @@index([key])
}

model Session {
  id           String   @id @default(cuid())
  token        String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  userId       String
  createdAt    DateTime @default(now())
  lastUsedAt   DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model AuditLog {
  id        String      @id @default(cuid())
  action    AuditAction
  entity    String
  entityId  String
  changes   Json?
  ipAddress String?
  userAgent String?
  userId    String
  timestamp DateTime    @default(now())
  user      User        @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([entity, entityId])
  @@index([timestamp])
}

// Debt management models per design
model DebtTab {
  id            String       @id @default(cuid())
  customerId    String
  status        DebtStatus   @default(OPEN)
  totalBalance  Float        @default(0)
  openedAt      DateTime     @default(now())
  closedAt      DateTime?

  // Relations
  customer      Customer     @relation(fields: [customerId], references: [id], onDelete: Cascade)
  transactions  DebtTransaction[]

  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@index([customerId])
  @@index([status])
}

model DebtTransaction {
  id               String              @id @default(cuid())
  debtTabId        String
  transactionType  DebtTransactionType
  containers       Float?
  unitPrice        Float?
  amount           Float
  balanceAfter     Float
  notes            String?
  adjustmentReason String?
  transactionDate  DateTime

  debtTab          DebtTab             @relation(fields: [debtTabId], references: [id], onDelete: Cascade)
  enteredBy        User                @relation(fields: [enteredById], references: [id])
  enteredById      String

  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  @@index([debtTabId])
  @@index([enteredById])
  @@index([transactionDate])
  @@index([transactionType])
}

model Payment {
  id                 String               @id
  amount             Float
  status             PaymentStatus        @default(UNPAID)
  paidAmount         Float                @default(0)
  dueDate            DateTime?
  notes              String?
  saleId             String               @unique
  customerId         String
  recordedById       String
  createdAt          DateTime             @default(now())
  updatedAt          DateTime
  Customer           Customer             @relation(fields: [customerId], references: [id])
  User               User                 @relation(fields: [recordedById], references: [id])
  Sale               Sale                 @relation(fields: [saleId], references: [id], onDelete: Cascade)
  PaymentTransaction PaymentTransaction[]

  @@index([customerId])
  @@index([dueDate])
  @@index([status])
}

model PaymentTransaction {
  id            String        @id
  amount        Float
  paymentMethod PaymentMethod @default(CASH)
  notes         String?
  paymentId     String
  recordedById  String
  createdAt     DateTime      @default(now())
  Payment       Payment       @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  User          User          @relation(fields: [recordedById], references: [id])

  @@index([createdAt])
  @@index([paymentId])
}

enum UserRole {
  ADMIN
  STAFF
}

enum Location {
  BANAI
  DOUBE_L
  JOVIL_3
  LOWER_LOOB
  PINATUBO
  PLASTIKAN
  SAN_ISIDRO
  UPPER_LOOB
  URBAN
  ZUNIGA
  WALK_IN
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
}

enum DebtStatus {
  OPEN
  CLOSED
}

enum DebtTransactionType {
  CHARGE
  PAYMENT
  ADJUSTMENT
}

enum PaymentMethod {
  CASH
}

enum PaymentStatus {
  UNPAID
  PARTIAL
  PAID
  OVERDUE
}

enum PaymentType {
  CASH
  CREDIT
}
